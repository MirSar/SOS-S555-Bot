using Discord;
using Discord.Commands;
using Discord.WebSocket;


// Endpoint api.cognitive.microsofttranslator.com

namespace SOSS555Bot.Commands.Translate
{
    /// <summary>
    /// This class contains the command to echo back a message.
    /// </summary>
    /// <remarks>
    /// The command is triggered  by the user typing "!echo <phrase>" in the chat.
    /// The bot will respond with the same phrase.
    /// </remarks>

    public class TranslateCommand : ModuleBase<SocketCommandContext>
    {
        [Summary("Translates a message to Russian")]
        [Command("translate")]
        [Alias("tr")]
        [RequireContext(ContextType.Guild)]
        [RequireUserPermission(GuildPermission.SendMessages)]

        public async Task TranslateAsync([Remainder][Summary("A phrase")] string phrase)
        {
            if (string.IsNullOrEmpty(phrase))
            {
                await ReplyAsync($"Usage: !tr <phrase>");
                return;
            }
            // Check if the phrase is too long
            if (phrase.Length > 2000)
            {
                await ReplyAsync($"The phrase is too long. Please keep it under 2000 characters.");
                return;
            }


            string APIKey = ;
            string APIEndpoint = "api.cognitive.microsofttranslator.com";
            string APIVersion = "3.0";
            string region = "norwayeast"; // Set the region for the translation service

            string targetLanguage = "ru"; // Set the target language to Russian
            string translationString = phrase; // Placeholder for the translation logic

            //string keyCredential = new AzureKeyCredential(APIKey);
            string endpoint = $"https://{APIEndpoint}/translate?api-version={APIVersion}&to={targetLanguage}";

            // Create a new HttpClient instance
            using var client = new HttpClient();
            client.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-Key", APIKey);
            client.DefaultRequestHeaders.Add("Ocp-Apim-Subscription-Region", region);
            client.DefaultRequestHeaders.Add("Accept", "application/json");

            // Create the request body
            var requestBody = new[]
            {
                    new { Text = phrase }
                };

            var jsonRequestBody = System.Text.Json.JsonSerializer.Serialize(requestBody);
            var content = new StringContent(jsonRequestBody, System.Text.Encoding.UTF8, "application/json");

            // try to send the request to the API and retrieve the translation
            try
            {
                var response = await client.PostAsync(endpoint, content);
                response.EnsureSuccessStatusCode();

                // Parse the response
                var responseString = await response.Content.ReadAsStringAsync();
                using var doc = System.Text.Json.JsonDocument.Parse(responseString);
                var root = doc.RootElement;
                if (root.ValueKind == System.Text.Json.JsonValueKind.Array &&
                    root.GetArrayLength() > 0 &&
                    root[0].TryGetProperty("translations", out var translations) &&
                    translations.ValueKind == System.Text.Json.JsonValueKind.Array &&
                    translations.GetArrayLength() > 0 &&
                    translations[0].TryGetProperty("text", out var textProp))
                {
                    translationString = textProp.GetString();
                }
                else
                {
                    throw new Exception("Unexpected response format from translation API.");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error: {ex.Message}");
                await ReplyAsync($"Error: {ex.Message}");
                return;
            }


            // Send the message to the channel
            Console.WriteLine($"Translation: {translationString}");
            await ReplyAsync((string)translationString);
        }
    }

}
